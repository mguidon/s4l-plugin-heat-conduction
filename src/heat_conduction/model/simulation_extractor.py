#!python3

import asyncio
import json
import logging
from abc import ABC, abstractmethod
from pathlib import Path
from enum import Enum

import heat_conduction.solver.driver.api_models as mdl
import heat_conduction.model.example_plots as example_plots

import s4l_core.simulator_plugins.common.plugin_plot_manager as ppm

import XCore as xc
import XCoreMath as xcm
import XPostProcessor as xp
import XPostProPython as pp
from XCore import Color, Unit

FILENAME_SUFFIX = ".vtr"
JSON_OUTPUT = "summary.json"

logger = logging.getLogger(__name__)


"""
Class Hierarchy for Simulation Extraction:

                            Has A                         Has A                           Has A
  ┌───────────────────────┐        ┌────────────────────┐        ┌──────────────────────┐          ┌──────────────────┐
  │ PythonModuleAlgorithm ├───────►│   AlgorithmImpl    ├───────►├ SimulationExtractor  ├─────────►│ IExtractorParent │
  │      (C++)            │        │      (Python)      │        │       Impl           │          │                  │
  └───────────────────────┘        └────────────────────┘        └──────────────────────┘          └──────────────────┘



  ┌───────────────┐     Is A     ┌──────────────────┐
  │ AlgorithmImpl ├─────────────►│ IExtractorParent │
  └───────────────┘              └──────────────────┘

"""


class IExtractorParent(ABC):
    """
    The interface for the parent of a simulation extractor for a
    particular simulation type.  It provides the child info about the simulation
    being extracted and allows for the addition of settings and output
    ports to the parent algorithm.
    """

    @abstractmethod
    def add_property(self, name: str, property: xc.Property) -> xc.Property:
        """
        Add a property to the parent C++ class for use in the settings
        n.b. checks that this property is not already present to avoid
        an overwrite during de-serialisation.
        """
        ...

    @property
    @abstractmethod
    def input_simulation(self) -> mdl.Simulation:
        """
        Get the simulation being extracted by this extractor
        """
        ...

    @property
    @abstractmethod
    def output_files_dir(self) -> Path:
        """
        Get the directory containing the output files being extracted from
        by this extractor
        """
        ...

    @abstractmethod
    def ResizeNumberOfOutputPorts(self, num_outputs: int) -> None:
        """
        Set the number of output ports
        """
        ...


class SimulationExtractorImpl:
    """
    Implementation of the heat conduction simulation results extractor.
    
    This class processes the output files generated by the heat conduction solver,
    including temperature and heat flux field data, and makes them available for
    visualization and analysis in the S4L post-processing environment.
    """

    FIELD_NAMES = ["Temperature", "HeatFlux"]

    def __init__(self, parent: "IExtractorParent") -> None:
        """
        Initializes the simulation extractor with references to the parent algorithm.
        
        Sets up empty collections for outputs and extractors that will be populated
        during the extraction process.
        
        Args:
            parent: The parent algorithm that provides access to output files
        """
        super().__init__()
        self._parent = parent
        self._outputs: list[xp.DataObject | None] = []
        self._extractors: list[xp.VtkFieldImporter] = []
        self._json_data_object: xp.JsonDataObject = xp.JsonDataObject()

    def _create_vtk_importer(self, filepath: Path) -> xp.VtkFieldImporter:
        """
        Creates a VTK field importer for a specific result file.
        
        Configures the importer with the correct filename and unit settings
        for importing VTK field data into the post-processor.
        
        Args:
            filepath: Path to the VTK file to import
            
        Returns:
            A configured VTK field importer
        """
        extractor = xp.VtkFieldImporter()
        extractor.FileName.Value = str(filepath)
        extractor.GridUnit.Value = 2  # mm
        assert (
            extractor.GridUnit.ValueDescription == "mm"
        )  # TODO Ensure units are consistent
        return extractor

    def _load_json_data(self, filepath: Path) -> xp.JsonDataObject:
        """
        Loads simulation summary data from a JSON file into a data object.
        
        Reads key summary statistics (min/max temperature, heat input, etc.)
        from the JSON file and creates a structured data object that can be
        displayed in the post-processor.
        
        Args:
            filepath: Path to the summary JSON file
            
        Returns:
            A JsonDataObject containing the structured summary data
        """
        with open(filepath) as fh:
            json_data = json.load(fh)

        self._json_data_object = xp.JsonDataObject()
        data_collection = self._json_data_object.AttributeSimpleDataCollection
        data_collection.InitAttributes("Summary", "", xc.Unit(""))
        data_collection.InitFieldValueAttribute(
            "min_temperature",
            "Minimal Temperature in simulation domain",
            xc.Unit("K"),
            xp.eTabularScalarType.kReal,
            1,
        )
        data_collection.InitFieldValueAttribute(
            "max_temperature",
            "Maximal Temperature in simulation domain",
            xc.Unit("K"),
            xp.eTabularScalarType.kReal,
            1,
        )
        data_collection.InitFieldValueAttribute(
            "mean_temperature",
            "Average Temperature in simulation domain",
            xc.Unit("K"),
            xp.eTabularScalarType.kReal,
            1,
        )
        data_collection.InitFieldValueAttribute(
            "argmin_index",
            "Grid Index min Temperature",
            xc.Unit(""),
            xp.eTabularScalarType.kInt,
            3,
        )
        data_collection.InitFieldValueAttribute(
            "argmax_index",
            "Grid Index max Temperature",
            xc.Unit(""),
            xp.eTabularScalarType.kInt,
            3,
        )
        data_collection.InitFieldValueAttribute(
            "total_heat_input",
            "Total heat input",
            xc.Unit("K"),
            xp.eTabularScalarType.kReal,
            1,
        )
        self._json_data_object.DataJson = self._json_data_object.AttributeJson

        data_collection = self._json_data_object.DataSimpleDataCollection
        data_collection.Snapshots = [1.0]

        data_collection.SetFieldValue(
            "min_temperature", 0, json_data["min_temperature"]
        )
        data_collection.SetFieldValue(
            "max_temperature", 0, json_data["max_temperature"]
        )
        data_collection.SetFieldValue(
            "mean_temperature", 0, json_data["mean_temperature"]
        )
        data_collection.SetFieldValue("argmin_index", 0, json_data["argmin_index"])
        data_collection.SetFieldValue("argmax_index", 0, json_data["argmax_index"])
        data_collection.SetFieldValue(
            "total_heat_input", 0, json_data["total_heat_input"]
        )

        return self._json_data_object

    def _collect_real_field_data(
        self, extractor: xp.VtkFieldImporter, field_name: str
    ) -> xp.FloatFieldData:
        """
        Retrieves field data of a specific name from a VTK field importer.
        
        Searches through the outputs of the VTK importer to find the field
        with the specified name, ensuring it has the correct data type.
        
        Args:
            extractor: The VTK field importer to get data from
            field_name: The name of the field to retrieve
            
        Returns:
            The float field data for the specified field
            
        Raises:
            AssertionError: If the field data is not found or has incorrect type
        """
        field_data = None
        for idx in range(extractor.NumberOfOutputPorts):
            data = extractor.GetOutput(idx)
            if data.Description == field_name:
                field_data = data
                assert isinstance(field_data, xp.FloatFieldData)
                field_data.Quantity.Name = field_name
        assert field_data is not None, f"Field data for {field_name} not found"
        return field_data

    def DoCheckInputConnections(self, inputs: list[xp.AlgorithmOutput]) -> bool:
        """
        Checks that input connections to this algorithm are valid.
        
        For this extractor, no inputs are expected as it reads directly from
        result files rather than connecting to other algorithm outputs.
        
        Args:
            inputs: List of input connections
            
        Returns:
            True if the inputs are valid (empty list in this case)
        """
        return len(inputs) == 0

    def DoComputeOutputAttributes(self) -> bool:
        """
        Sets up the extractors and computes output attributes for all fields.
        
        This method is called during the preparation phase of the algorithm execution.
        It creates VTK importers for each field, configures output ports, and
        loads the summary JSON data.
        
        Returns:
            True if the attributes were computed successfully
        """
        self._extractors = []

        # Create VTK importers for each field
        for field_name in self.FIELD_NAMES:
            filepath = self._parent.output_files_dir / f"{field_name}{FILENAME_SUFFIX}"
            extractor = self._create_vtk_importer(filepath)
            self._extractors.append(extractor)

        num_outputs = len(self._extractors) + 1
        self._parent.ResizeNumberOfOutputPorts(num_outputs)

        # Update attributes for all extractors
        if not all(extractor.UpdateAttributes() for extractor in self._extractors):
            raise RuntimeError("Failed to update attributes for extractors")

        self._load_json_data(self._parent.output_files_dir / JSON_OUTPUT)

        self._outputs = [None] * (num_outputs)
        self._update_outputs()
        return True

    def _update_outputs(self) -> None:
        """
        Updates the cached output data objects with current extractor results.
        
        Collects field data from all extractors and updates the output cache
        to ensure the latest data is available when requested by the post-processor.
        """
        num_outputs = len(self._extractors) + 1
        assert len(self.FIELD_NAMES) == num_outputs - 1
        assert len(self._outputs) == num_outputs

        for i, extractor in enumerate(self._extractors):
            field_data = self._collect_real_field_data(extractor, self.FIELD_NAMES[i])
            self._outputs[i] = field_data

        self._outputs[num_outputs - 1] = self._json_data_object

    def DoComputeOutputData(self, index: int) -> bool:
        """
        Computes the output data for a specific output port.
        
        Triggers computation in all extractors and updates the output cache.
        This method is called when the post-processor needs data from a specific
        output port.
        
        Args:
            index: The index of the output port to compute
            
        Returns:
            True if the computation was successful
        """
        # Update all extractors
        if not all(extractor.Update() for extractor in self._extractors):
            return False

        self._update_outputs()
        return True

    def GetOutputDataObject(self, output_index: int = 0) -> xp.DataObject:
        """
        Retrieves the data object for a specific output port.
        
        Returns the appropriate field data or summary data based on the
        requested output index. Ensures outputs are computed if they
        haven't been already.
        
        Args:
            output_index: The index of the output port to get data from
            
        Returns:
            The data object for the specified output port
        """
        if not self._outputs:
            self.DoComputeOutputAttributes()

        output = self._outputs[output_index]
        return output if output is not None else xp.FloatFieldData()

class ExampleEnum(Enum):
    ENTRY_1 = "Enum Entry 1"
    ENTRY_2 = "Enum Entry 2"
    ENTRY_3 = "Enum Entry 3"

class AlgorithmImpl(IExtractorParent):
    """
    Python-side implementation of the S4L post-processor algorithm for result extraction.
    
    This class bridges between the C++ PythonModuleAlgorithm and the Python-based
    SimulationExtractorImpl. It handles properties, input/output management, and
    delegates the actual extraction work to SimulationExtractorImpl.
    """

    def __init__(self, parent: pp.PythonModuleAlgorithm) -> None:
        """
        Initializes the algorithm implementation with a reference to the parent C++ algorithm.
        
        Sets up the UI properties and configures the parent algorithm with basic settings.
        
        Args:
            parent: The C++ PythonModuleAlgorithm that hosts this implementation
        """
        super().__init__()

        self._extractor: SimulationExtractorImpl | None = None

        self._parent = parent
        self._parent.SetOneExecutionUpdatesAll(True)

        prop = self.add_property("results_dir", xc.PropertyString(""))
        prop.Description = "Results Dir."

        parent.Icon = "icons/XPostProcessor/field_extractor.ico"


        prop = self.add_property("show_settings", xc.PropertyBool(True))
        prop.Description = "Show Settings"

        self.show_settings_prop = prop

        # Group property to organize related settings
        example_group = self.add_property("example_settings", xc.PropertyGroup())
        assert isinstance(example_group, xc.PropertyGroup)

        example_group.Description = "Example Settings"

        self.example_group = example_group

        prop = example_group.Add("string", xc.PropertyString("This is a string"))
        prop.Description = "String Property"

        # Number properties
        prop = example_group.Add("int", xc.PropertyInt(12))
        prop.Description = "Integer Property"
        prop.Min = 0
        prop.Max = 100

        prop = example_group.Add("real", xc.PropertyReal(1.5))
        prop.Description = "Real Property"
        prop.Min = 0.0
        prop.Max = 10.0
        prop.Unit = Unit("K")  # Kelvin unit
        
        # Slider property
        prop = example_group.Add("slider_value", xc.PropertySlider(25.0))
        prop.Description = "Slider Value"
        prop.Min = 0.0
        prop.Max = 100.0
        prop.Step = 5.0
        
        # Tuple properties
        prop = example_group.Add("int_tuple", xc.PropertyIntTuple(value=[1,2,3], min=[1, 1, 1], max=[1000, 1000, 1000]))
        prop.Description = "Integer Tuple Property"

        prop = example_group.Add("real_tuple", xc.PropertyRealTuple(value=[0.1, 0.2, 0.3, 0.4], min=[0.0, -1.0, 2.0, 5.0], max=[100.00, 200.0, 300.0, 400.2]))
        prop.Description = "Real Tuple Property"
        
        # Enum property
        prop = example_group.Add("enum", xc.PropertyEnum(
            [
                ExampleEnum.ENTRY_1.value,
                ExampleEnum.ENTRY_2.value,
                ExampleEnum.ENTRY_3.value,
            ],
            0,
        ))
        prop.Description = "Enum Property"
        
        # Boolean property
        prop = example_group.Add("bool_value", xc.PropertyBool(False))
        prop.Description = "Boolean Property"
        
        # Color property
        color = Color(red=0.5, green=0.7, blue=0.9, alpha=1.0)
        prop = example_group.Add("color", xc.PropertyColor(color))
        prop.Description = "Color Property"
        
        # File property
        prop = example_group.Add("input_file", xc.PropertyFile(is_folder=False, is_input=True))
        prop.Description = "Input File"
        prop.Filter = "JSON Files (*.json)|*.json|All Files (*.*)|*.*"

        prop = example_group.Add("output_file", xc.PropertyFile(is_folder=False, is_input=False))
        prop.Description = "Output File"
        prop.Filter = "JSON Files (*.json)|*.json|All Files (*.*)|*.*"
        
        # Directory property
        prop = example_group.Add("input_folder", xc.PropertyFile(is_folder=True, is_input=True))
        prop.Description = "Input Folder"

        prop = example_group.Add("output_folder", xc.PropertyFile(is_folder=True, is_input=False))
        prop.Description = "Output Folder"

        # Plots
        plots_group = self.add_property("plot_examples", xc.PropertyGroup())
        assert isinstance(plots_group, xc.PropertyGroup)

        plots_group.Description = "Example Plots"

        self.plots_group = plots_group

        prop = plots_group.Add("plots", xc.PropertyEnum(
            [
                "generate_line_plot",
                "generate_multi_line_plot",
                "generate_scatter_plot",
                "generate_bar_plot",
                "generate_heatmap",
                "generate_3d_scatter",
                "generate_3d_surface",
                "generate_contour_plot",
                "generate_histogram",
                "generate_box_plot",
            ],
            0,
        ))
        prop.Description = "Example Plots"

        self.plot_selector_prop = prop

        prop = plots_group.Add("show_plot", xc.PropertyPushButton())
        prop.Description = "Show Plot"
       
        self.show_plot_prop = prop

        # connect not right away, but after the seriazliation
        asyncio.get_event_loop().call_soon(
            self._connect_signals
        )

    def _connect_signals(self) -> None:

        def visibility_changed(
                prop: xc.Property, mod_type: xc.PropertyModificationTypeEnum
            ):
                if mod_type != xc.kPropertyModified:
                    return
                if prop == self.show_settings_prop:
                    assert isinstance(prop, xc.PropertyBool)
                    # Toggle visibility of the example group based on the property value
                    self.example_group.Visible = prop.Value
        
        self.show_settings_prop.OnModified.Connect(visibility_changed)

        def show_plot():
            assert isinstance(self.plot_selector_prop, xc.PropertyEnum)

            plot_name = self.plot_selector_prop.ValueDescription
            plot_data = getattr(example_plots, plot_name)()
            ppm.create_plot(plot_data)
                
        assert isinstance(self.show_plot_prop, xc.PropertyPushButton)
        self.show_plot_prop.OnClicked.Connect(show_plot)



    def add_property(self, name: str, property: xc.Property) -> xc.Property:
        """
        Adds a property to the parent algorithm, avoiding overwriting existing properties.
        
        This method is used to add UI-configurable properties to the algorithm,
        checking first if the property already exists (which might happen during
        deserialization).
        
        Args:
            name: The name of the property to add
            property: The property object to add
            
        Returns:
            The added or existing property
        """
        if (
            existing_prop := self._parent.FindChild(name)
        ) is None:  # make sure we don't overwrite a deserialized property
            return self._parent.Add(name, property)
        else:
            assert isinstance(existing_prop, xc.Property)
            return existing_prop

    def _results_dir(self) -> Path:
        """
        Retrieves the results directory path from the properties.
        
        Attempts to resolve the configured results directory path, checking for
        both absolute and relative paths (relative to the current document).
        
        Returns:
            The resolved path to the results directory
            
        Raises:
            RuntimeError: If the results directory cannot be found
        """
        if (results_dir_prop := self._parent.FindChild("results_dir")) is None:
            raise RuntimeError("Failed to find results_dir child")

        assert isinstance(results_dir_prop, xc.PropertyString)

        assert len(results_dir_prop.Value) > 0, "Results dir was not set"

        stored_path = Path(results_dir_prop.Value)
        if stored_path.is_dir():
            results_path = stored_path
        else:  # perhaps its is a path relative to the current smash file
            results_relpath = Path(results_dir_prop.Value)

            app = xc.GetApp()
            doc = app.Document

            results_path = Path(doc.FileFolder) / results_relpath
            if not results_path.is_dir():
                raise RuntimeError(
                    f"Failed to find results_dir, tried: {stored_path} and {results_path}"
                )

        return results_path

    def _input_filepath(self) -> Path:
        """
        Determines the path to the input file used for the simulation.
        
        Locates the original input file in the expected location within the
        results directory structure.
        
        Returns:
            The path to the input JSON file
            
        Raises:
            ValueError: If the input file cannot be found
        """
        input_filepath = self._results_dir() / "input_files" / "input_file.json"
        if not input_filepath.is_file():
            raise ValueError(f"Could not find: {input_filepath}")

        return input_filepath

    @property
    def input_simulation(self) -> mdl.Simulation:
        """
        Retrieves the simulation model from the input file.
        
        Loads and deserializes the original simulation model from the
        JSON input file used for the simulation run.
        
        Returns:
            The deserialized Simulation object
        """
        with open(self._input_filepath()) as fh:
            sim: mdl.Simulation = mdl.Simulation.schema().loads(fh.read())  # type: ignore

        return sim

    @property
    def output_files_dir(self) -> Path:
        """
        Provides the path to the directory containing simulation output files.
        
        Returns:
            The path to the output_files directory within the results folder
        """
        return self._results_dir() / "output_files"

    def ResizeNumberOfOutputPorts(self, num_outputs: int) -> None:
        """
        Adjusts the number of output ports on the parent algorithm.
        
        This method is called by the extractor implementation to configure
        the correct number of output ports for the available result fields.
        
        Args:
            num_outputs: The number of output ports to configure
        """
        self._parent.ResizeNumberOfOutputPorts(num_outputs)

    def DoCheckInputConnections(self, inputs: list[xp.AlgorithmOutput]) -> bool:
        """
        Validates the input connections to the algorithm.
        
        Delegates to the extractor implementation to check if the inputs
        are valid for this algorithm.
        
        Args:
            inputs: The list of input connections
            
        Returns:
            True if the inputs are valid
        """
        extractor = self._get_or_create_extractor()
        return extractor.DoCheckInputConnections(inputs)

    def DoComputeOutputAttributes(self) -> bool:
        """
        Prepares the output attributes for all algorithm outputs.
        
        Delegates to the extractor implementation to compute and configure
        all output attributes.
        
        Returns:
            True if the attributes were computed successfully
        """
        extractor = self._get_or_create_extractor()
        return extractor.DoComputeOutputAttributes()

    def DoComputeOutputData(self, index: int) -> bool:
        """
        Computes the output data for a specific output port.
        
        Delegates to the extractor implementation to compute the
        requested output data.
        
        Args:
            index: The index of the output port to compute
            
        Returns:
            True if the data was computed successfully
        """
        extractor = self._get_or_create_extractor()
        return extractor.DoComputeOutputData(index)

    def _get_or_create_extractor(self) -> "SimulationExtractorImpl":
        """
        Gets or creates the appropriate extractor implementation.
        
        Ensures that a simulation extractor instance exists and is of the
        correct type for the current simulation.
        
        Returns:
            The simulation extractor implementation
        """
        extractor_cls = SimulationExtractorImpl

        if not isinstance(self._extractor, extractor_cls):
            self._extractor = extractor_cls(self)

        return self._extractor

    def GetOutputDataObject(self, output_index: int = 0) -> xp.DataObject:
        """
        Retrieves the data object for a specific output port.
        
        Delegates to the extractor implementation to get the requested
        output data object.
        
        Args:
            output_index: The index of the output port to get data from
            
        Returns:
            The data object for the specified output port
        """
        extractor = self._get_or_create_extractor()
        return extractor.GetOutputDataObject(output_index)
